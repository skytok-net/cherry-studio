# TSX Artifacts Design Theory and Implementation

## Overview

The TSX Artifacts system enables real-time preview and interactive editing of React/TypeScript components generated by AI assistants. This document explains the architectural design, transpilation mechanisms, error handling, and automated retry/fix systems.

## Table of Contents

1. [Architecture Overview](#architecture-overview)
2. [Component Detection and Rendering](#component-detection-and-rendering)
3. [Transpilation Pipeline](#transpilation-pipeline)
4. [Error Detection Mechanisms](#error-detection-mechanisms)
5. [Automatic Retry System](#automatic-retry-system)
6. [Manual Fix Code Mechanism](#manual-fix-code-mechanism)
7. [Message Context Integration](#message-context-integration)
8. [UI/UX Design Considerations](#uiux-design-considerations)
9. [Security and Sandboxing](#security-and-sandboxing)

---

## Architecture Overview

### Design Philosophy

The TSX Artifacts system follows a **progressive enhancement** approach:

1. **Detection**: Identify TSX/JSX code blocks in markdown streams
2. **Transpilation**: Convert TypeScript/JSX to browser-executable JavaScript
3. **Sandboxing**: Render components in isolated iframe environments
4. **Error Handling**: Detect and respond to compilation/rendering errors
5. **Self-Healing**: Automatically request fixes from the generating LLM

### Component Hierarchy

```
CodeBlock (Markdown Parser)
  └── TsxArtifactsCard (Display Card)
      └── TsxArtifactsPopup (Full Preview Modal)
          ├── CodeEditor (Editable Code View)
          └── PreviewFrame (Sandboxed iframe)
```

### Data Flow

```
Markdown Stream → CodeBlock Detection → TsxArtifactsCard
                                              ↓
                                    User Opens Preview
                                              ↓
                                    TsxArtifactsPopup
                                              ↓
                                    Transpile TSX → JS
                                              ↓
                                    Render in iframe
                                              ↓
                                    Error Detection?
                                              ↓
                                    Auto Retry / Manual Fix
```

---

## Component Detection and Rendering

### Detection Mechanism

The system detects TSX artifacts through the markdown parsing pipeline:

**Location**: `src/renderer/src/pages/home/Markdown/CodeBlock.tsx`

```typescript
// Language detection from markdown code fence
const languageMatch = /language-([\w-+]+)/.exec(className || '')
const language = languageMatch?.[1] ?? null

// TSX/JSX detection
if (language === 'tsx' || language === 'jsx') {
  const isOpenFence = isOpenFenceBlock(children?.length, languageMatch?.[1]?.length, node?.position)
  return <TsxArtifactsCard tsx={children} onSave={handleSave} isStreaming={isStreaming && isOpenFence} blockId={blockId} />
}
```

**Key Design Decisions**:

1. **Streaming Support**: Detects incomplete code blocks during streaming (`isOpenFence`)
2. **Block Context**: Passes `blockId` to maintain connection to the source message
3. **Component Name Extraction**: Uses `extractComponentName()` utility to derive titles

### Component Name Extraction

**Location**: `src/renderer/src/utils/formats.ts`

The system attempts multiple patterns to extract component names:

1. Function components: `function ComponentName()` or `const ComponentName =`
2. Class components: `class ComponentName extends`
3. Arrow functions: `const ComponentName = () =>`

This provides meaningful titles even when components aren't explicitly named.

---

## Transpilation Pipeline

### Transpiler Selection Strategy

The system uses a **dual-transpiler approach** with automatic fallback:

1. **Primary**: `esbuild-wasm` (fast, modern, WebAssembly-based)
2. **Fallback**: `@babel/standalone` (comprehensive, proven compatibility)

**Why This Approach?**

- **Performance**: esbuild-wasm is significantly faster for large codebases
- **Reliability**: Babel provides broader compatibility as fallback
- **Offline Support**: Both are bundled as npm packages (no CDN dependency)

### Transpiler Loading

**Lazy Loading Pattern**:

```typescript
// Module-level cache to prevent reloading
let esbuildWasm: any = null
let BabelStandalone: any = null

const loadEsbuildWasm = async () => {
  if (esbuildWasm) return esbuildWasm
  const esbuildModule = await import('esbuild-wasm')
  esbuildWasm = esbuildModule.default || esbuildModule
  return esbuildWasm
}
```

**Initialization Strategy**:

1. Load transpilers only when popup opens (`useEffect` with `open` dependency)
2. Try esbuild-wasm first (faster initialization)
3. Fall back to Babel if esbuild fails
4. Cache loaded transpilers to avoid re-initialization

### WASM File Resolution

**Challenge**: Electron/Vite environments require special handling for WASM files.

**Solution**: Multiple path resolution attempts:

```typescript
// Approach 1: import.meta.url (Vite-compatible)
const wasmPath = new URL('esbuild-wasm/esbuild.wasm', import.meta.url).href

// Approach 2: Relative path fallback
const wasmPath2 = '/node_modules/esbuild-wasm/esbuild.wasm'
```

### Import Transformation

**Problem**: TSX code uses ES module imports (`import React from 'react'`), but libraries are loaded as global variables in the iframe.

**Solution**: String-based import transformation before transpilation:

```typescript
const importMap: Record<string, string> = {
  'react': 'React',
  'react-dom': 'ReactDOM',
  '@xyflow/react': 'ReactFlow',
  // ... more mappings
}

// Replace import statements with global variable assignments
Object.entries(importMap).forEach(([module, globalVar]) => {
  const importRegex = new RegExp(`import\\s+([\\w*]+)\\s+from\\s+['"]${module}['"]`, 'g')
  processedTsx = processedTsx.replace(importRegex, `const $1 = window.${globalVar};`)
})
```

**Design Rationale**:

- **Pre-transpilation**: Transform before transpiler sees imports (avoids transpiler errors)
- **String-based**: Simpler than AST manipulation, sufficient for common cases
- **Extensible**: Easy to add new library mappings

### Transpilation Configuration

**esbuild Configuration**:

```typescript
const transformResult = await esbuild.transform(processedTsx, {
  loader: 'tsx',
  format: 'iife', // Immediately Invoked Function Expression
  target: 'es2020',
  jsx: 'transform', // Transform JSX to React.createElement
  jsxFactory: 'React.createElement',
  jsxFragment: 'React.Fragment',
  globalName: 'window' // Make exports available on window
})
```

**Key Settings**:

- **`format: 'iife'`**: Wraps code in `(function() { ... })()` for immediate execution
- **`jsx: 'transform'`**: Converts JSX to function calls (not JSX runtime)
- **`globalName: 'window'`**: Ensures exports are accessible globally

---

## Error Detection Mechanisms

### Multi-Layer Error Detection

The system implements **three layers** of error detection:

#### 1. Transpilation Errors

**Detection Point**: During `transpileAndRender()` execution

```typescript
try {
  const transformResult = await esbuild.transform(processedTsx, {...})
  // ... render code
} catch (error) {
  const errorMessage = error instanceof Error ? error.message : 'Failed to transpile TSX code'
  setPreviewError(errorMessage)
  lastErrorRef.current = errorMessage
  
  // Trigger automatic retry
  if (retryAttempt < MAX_AUTO_RETRY_ATTEMPTS && blockId) {
    handleAutoRetry(errorMessage)
  }
}
```

**Error Types Caught**:
- Syntax errors
- Type errors (if TypeScript checking enabled)
- Import resolution failures
- Transpiler initialization failures

#### 2. Runtime Errors (iframe)

**Detection Point**: After iframe content loads

```typescript
useEffect(() => {
  const handleIframeError = () => {
    const iframeDoc = iframe.contentDocument || iframe.contentWindow?.document
    if (iframeDoc) {
      const errorElement = iframeDoc.querySelector('.error')
      if (errorElement) {
        const errorText = errorElement.textContent || 'Rendering error occurred'
        setPreviewError(errorText)
        lastErrorRef.current = errorText
        
        // Trigger automatic retry
        if (retryAttempt < MAX_AUTO_RETRY_ATTEMPTS && blockId) {
          handleAutoRetry(errorText)
        }
      }
    }
  }
  
  // Check after delay to allow rendering
  const checkTimeout = setTimeout(handleIframeError, 1000)
}, [open, retryAttempt, blockId])
```

**Error Types Caught**:
- React rendering errors
- Component not found errors
- Runtime JavaScript errors
- Missing dependency errors

#### 3. Component Detection Failures

**Detection Point**: During component resolution in iframe

```typescript
// Try to find component
let ComponentToRender = null
if (typeof App !== 'undefined') {
  ComponentToRender = App
} else if (typeof Component !== 'undefined') {
  ComponentToRender = Component
} else {
  // Fallback: find any exported component
  const componentNames = Object.keys(window).filter(key => 
    typeof window[key] === 'function' && 
    /^[A-Z]/.test(key) &&
    key !== 'React' && key !== 'ReactDOM' && key !== 'cn'
  )
  if (componentNames.length > 0) {
    ComponentToRender = window[componentNames[0]]
  }
}

if (!ComponentToRender) {
  throw new Error('No React component found. Make sure to export a component...')
}
```

**Design Rationale**:

- **Multiple Detection Points**: Catches errors at different stages
- **Delayed iframe Check**: Allows time for rendering before error detection
- **Error Persistence**: Stores error in `lastErrorRef` for retry context

---

## Automatic Retry System

### Design Goals

1. **Transparency**: User should see retry progress
2. **Intelligence**: Only retry on actual errors (not user edits)
3. **Rate Limiting**: Prevent rapid-fire requests
4. **Context Preservation**: Maintain conversation context

### Retry Configuration

```typescript
const MAX_AUTO_RETRY_ATTEMPTS = 4 // 0-indexed, so 5 total attempts
```

**Why 5 Attempts?**

- **Balance**: Enough attempts to handle transient issues, not so many as to spam
- **User Experience**: Clear indication when manual intervention needed
- **Cost Consideration**: Limits API calls for LLM fix requests

### Retry State Management

```typescript
const [retryAttempt, setRetryAttempt] = useState(0)
const lastErrorRef = useRef<string | null>(null)
const retryTimeoutRef = useRef<NodeJS.Timeout | null>(null)
```

**State Variables**:

- **`retryAttempt`**: Current attempt number (0-indexed)
- **`lastErrorRef`**: Persists error message across renders
- **`retryTimeoutRef`**: Allows cleanup of pending retries

### Retry Reset Logic

```typescript
// Reset retry attempt when TSX content changes (new code received)
useEffect(() => {
  if (tsx.trim()) {
    setRetryAttempt(0)
    setPreviewError(null)
    lastErrorRef.current = null
  }
}, [tsx])
```

**Design Rationale**:

- **New Code = Fresh Start**: When LLM provides new code, reset retry counter
- **Prevents Infinite Loops**: Stops retrying on same error
- **User Edits**: Manual edits also reset (user is fixing it themselves)

### Exponential Backoff

```typescript
const handleAutoRetry = useCallback((errorMessage: string) => {
  if (retryAttempt >= MAX_AUTO_RETRY_ATTEMPTS) {
    return // Max attempts reached
  }

  // Exponential backoff: 2s, 4s, 6s, 8s
  retryTimeoutRef.current = setTimeout(async () => {
    setRetryAttempt((prev) => prev + 1)
    // ... send fix request
  }, 2000 * (retryAttempt + 1))
}, [retryAttempt, blockId, tsx, dispatch, getMessageContext])
```

**Backoff Strategy**:

- **Attempt 1**: 2 seconds delay
- **Attempt 2**: 4 seconds delay
- **Attempt 3**: 6 seconds delay
- **Attempt 4**: 8 seconds delay

**Why Exponential Backoff?**

- **Rate Limiting**: Prevents overwhelming the LLM API
- **Network Considerations**: Allows time for previous requests to complete
- **User Experience**: Gives visual feedback between attempts

### Retry Flow Diagram

```
Error Detected
    ↓
Check: retryAttempt < MAX_AUTO_RETRY_ATTEMPTS?
    ↓ Yes
Wait: Exponential backoff delay
    ↓
Increment: retryAttempt++
    ↓
Get Message Context (assistant, topic, message)
    ↓
Construct Fix Prompt (code + error)
    ↓
Send Fix Request to LLM
    ↓
Wait for Response (new TSX code)
    ↓
New Code Received → Reset retryAttempt = 0
    ↓
Transpile & Render New Code
    ↓
Success? → Done
    ↓ No
Repeat (if attempts remaining)
```

### UI Feedback

**Retry Progress Display**:

```typescript
{retryAttempt > 0 && (
  <RetryInfo>
    {t('tsx_artifacts.retry.attempt', 'Auto-retry attempt {{attempt}}/{{max}}', {
      attempt: retryAttempt,
      max: MAX_AUTO_RETRY_ATTEMPTS + 1
    })}
  </RetryInfo>
)}
```

**Max Retries Message**:

```typescript
{retryAttempt >= MAX_AUTO_RETRY_ATTEMPTS && (
  <MaxRetriesMessage>
    {t('tsx_artifacts.retry.max_reached', 'Maximum retry attempts reached...')}
  </MaxRetriesMessage>
)}
```

---

## Manual Fix Code Mechanism

### User-Initiated Fixes

The "Fix Code" button provides **manual control** over the fix process:

```typescript
const handleFixCode = useCallback(async () => {
  if (!blockId || !lastErrorRef.current) return

  setIsFixing(true)
  try {
    const context = getMessageContext()
    if (!context) {
      window.toast.error(t('tsx_artifacts.fix.error.no_context'))
      return
    }

    const { message, assistant, topic } = context

    // Construct fix prompt
    const fixPrompt = `The following React/TSX code has a compilation or rendering error. Please fix it:

\`\`\`tsx
${tsx}
\`\`\`

Error: ${lastErrorRef.current}

Please provide the corrected code in a \`\`\`tsx code block.`

    const { message: userMessage } = getUserMessage({
      content: fixPrompt,
      assistant,
      topic
    })

    await dispatch(sendMessage(userMessage, assistant, topic.id))
    window.toast.success(t('tsx_artifacts.fix.requested'))
  } catch (error) {
    logger.error('Failed to send fix request:', error as Error)
    window.toast.error(t('tsx_artifacts.fix.error.send_failed'))
  } finally {
    setIsFixing(false)
  }
}, [blockId, tsx, dispatch, t, getMessageContext])
```

### Fix Prompt Design

**Structure**:

1. **Context**: "The following React/TSX code has an error"
2. **Code Block**: Full TSX code in markdown code fence
3. **Error Details**: Specific error message
4. **Instruction**: "Please provide the corrected code in a ```tsx code block"

**Why This Format?**

- **Clear Context**: LLM understands what's being fixed
- **Structured Input**: Code fence format is familiar to LLMs
- **Specific Output**: Requesting TSX code block ensures parseable response

### Button States

```typescript
<Button
  type="primary"
  icon={<Wand2 size={16} />}
  loading={isFixing}
  onClick={handleFixCode}
  disabled={isFixing || retryAttempt >= MAX_AUTO_RETRY_ATTEMPTS}>
  {isFixing
    ? t('tsx_artifacts.fix.requesting', 'Requesting fix...')
    : t('tsx_artifacts.fix.button', 'Fix Code')}
</Button>
```

**State Management**:

- **Loading**: Shows spinner while request is in flight
- **Disabled**: Prevents clicks during request or after max retries
- **Visual Feedback**: Icon and text change based on state

### Manual vs Automatic Fixes

**Differences**:

| Aspect | Automatic Retry | Manual Fix |
|--------|----------------|------------|
| **Trigger** | Error detected | User clicks button |
| **Timing** | Exponential backoff | Immediate |
| **User Control** | Automatic | User-initiated |
| **Retry Limit** | 5 attempts | Unlimited |
| **Use Case** | Transient errors | Persistent issues |

**Design Rationale**:

- **Automatic**: Handles common, fixable errors without user intervention
- **Manual**: Gives users control when automatic retries fail or user wants immediate fix

---

## Message Context Integration

### Context Retrieval

**Challenge**: Need to find the assistant, topic, and message that generated the code block.

**Solution**: Traverse Redux store using `blockId`:

```typescript
const getMessageContext = useCallback(() => {
  if (!blockId) return null

  try {
    // Get block from store
    const block = messageBlocksSelectors.selectById(store.getState(), blockId)
    if (!block || !block.messageId) return null

    // Search across all assistants and topics
    const state = store.getState()
    const assistants = state.assistants.assistants
    
    for (const assistant of assistants) {
      for (const topic of assistant.topics) {
        const messages = selectMessagesForTopic(state, topic.id)
        const message = messages.find((m) => m.id === block.messageId)
        if (message) {
          return { message, assistant, topic }
        }
      }
    }
    
    return null
  } catch (error) {
    logger.error('Failed to get message context:', error as Error)
    return null
  }
}, [blockId])
```

**Design Rationale**:

- **Comprehensive Search**: Searches all assistants/topics (handles edge cases)
- **Error Handling**: Returns null if context unavailable (graceful degradation)
- **Performance**: Uses Redux selectors (memoized, efficient)

### Context Usage

**Fix Request Construction**:

```typescript
const { message, assistant, topic } = context

// Use same assistant that generated original code
const { message: userMessage } = getUserMessage({
  content: fixPrompt,
  assistant, // Same assistant
  topic      // Same topic (conversation context)
})

await dispatch(sendMessage(userMessage, assistant, topic.id))
```

**Why Same Context?**

- **Continuity**: Maintains conversation flow
- **Model Consistency**: Uses same LLM that generated code (better fixes)
- **Context Awareness**: LLM has full conversation history

### Block ID Propagation

**Propagation Chain**:

```
CodeBlock (receives blockId from markdown parser)
  ↓
TsxArtifactsCard (receives blockId prop)
  ↓
TsxArtifactsPopup (receives blockId prop)
  ↓
getMessageContext() (uses blockId to find context)
  ↓
sendMessage() (uses context for fix request)
```

**Design Decision**: Pass `blockId` through component tree rather than using global state.

**Rationale**:
- **Explicit Dependencies**: Clear data flow
- **Testability**: Easy to mock/test
- **Type Safety**: TypeScript ensures correct prop types

---

## UI/UX Design Considerations

### Error Preview Layout

```typescript
<ErrorPreview>
  <ErrorHeader>
    <div>
      <h3>Preview Error</h3>
      {retryAttempt > 0 && <RetryInfo>Auto-retry attempt 2/5</RetryInfo>}
    </div>
    {blockId && (
      <FixButtonContainer>
        <Button onClick={handleFixCode}>Fix Code</Button>
      </FixButtonContainer>
    )}
  </ErrorHeader>
  <pre>{previewError}</pre>
  {retryAttempt >= MAX_AUTO_RETRY_ATTEMPTS && (
    <MaxRetriesMessage>Maximum retry attempts reached...</MaxRetriesMessage>
  )}
</ErrorPreview>
```

**Layout Principles**:

1. **Error Prominence**: Error message is primary content
2. **Action Accessibility**: Fix button easily accessible
3. **Progress Visibility**: Retry attempts clearly shown
4. **Guidance**: Max retries message guides user action

### Loading States

**Transpiling State**:

```typescript
{isTranspiling ? (
  <LoadingPreview>
    <p>Transpiling and rendering...</p>
  </LoadingPreview>
) : previewError ? (
  <ErrorPreview>...</ErrorPreview>
) : (
  <PreviewFrame>...</PreviewFrame>
)}
```

**Design Rationale**:

- **Clear Feedback**: User knows system is working
- **State Transitions**: Smooth transitions between states
- **Non-Blocking**: Loading doesn't prevent other actions

### View Modes

**Three View Modes**:

1. **Split**: Code editor + Preview side-by-side
2. **Code**: Code editor only
3. **Preview**: Preview only

**Why Multiple Views?**

- **Flexibility**: Users can focus on what they need
- **Screen Space**: Adapts to different screen sizes
- **Workflow**: Supports different editing workflows

---

## Security and Sandboxing

### iframe Sandbox Attributes

```typescript
<PreviewFrame
  sandbox="allow-scripts allow-same-origin allow-forms allow-modals allow-popups allow-presentation"
/>
```

**Sandbox Permissions**:

- **`allow-scripts`**: Enables JavaScript execution (required for React)
- **`allow-same-origin`**: Allows access to parent origin (for error detection)
- **`allow-forms`**: Enables form interactions
- **`allow-modals`**: Allows alert/confirm dialogs
- **`allow-popups`**: Enables window.open()
- **`allow-presentation`**: Enables Presentation API

**Security Considerations**:

- **Isolation**: Code runs in isolated iframe (can't access parent DOM)
- **Limited Permissions**: Only necessary permissions granted
- **No Network Access**: iframe can't make arbitrary network requests (CDN scripts loaded by parent)

### Library Loading Strategy

**CDN-Based Loading** (in iframe HTML):

```html
<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
```

**Why CDN?**

- **Size**: Avoids bundling large libraries in main app
- **Caching**: Browser caches CDN resources
- **Updates**: Can use latest versions without rebuilding

**Security Note**: CDN scripts are loaded in sandboxed iframe, limiting potential security impact.

### Code Injection Prevention

**Design Decisions**:

1. **No eval()**: Transpiled code uses function execution, not eval()
2. **Sandboxed Execution**: All code runs in isolated iframe
3. **No File System Access**: iframe can't access local files
4. **Limited Network**: Only CDN resources accessible

---

## Performance Optimizations

### Lazy Loading

**Transpilers**: Only loaded when popup opens

```typescript
useEffect(() => {
  if (!open) return
  loadTranspilers()
}, [open])
```

**Benefits**:
- **Initial Load**: Faster app startup
- **Memory**: Only loads when needed
- **Network**: Reduces initial bundle size

### Caching

**Transpiler Cache**:

```typescript
let esbuildWasm: any = null // Module-level cache
let BabelStandalone: any = null
```

**Benefits**:
- **Reuse**: Transpilers loaded once, reused across sessions
- **Performance**: Avoids re-initialization overhead

### Debouncing

**Error Detection Delay**:

```typescript
const checkTimeout = setTimeout(handleIframeError, 1000)
```

**Rationale**:
- **Rendering Time**: Allows iframe to render before checking
- **False Positives**: Prevents detecting errors before render completes

---

## Future Enhancements

### Potential Improvements

1. **Incremental Transpilation**: Only re-transpile changed code sections
2. **Error Categorization**: Different retry strategies for different error types
3. **User Preferences**: Configurable retry attempts and backoff timing
4. **Error History**: Track which errors were auto-fixed vs manual
5. **Component Library**: Pre-built component templates for common patterns
6. **Hot Reload**: Live preview updates as user edits code
7. **Type Checking**: Optional TypeScript type checking in preview
8. **Dependency Management**: Automatic dependency resolution and loading

### Extension Points

The architecture supports easy extension:

- **New Transpilers**: Add to `loadTranspilers()` function
- **New Libraries**: Add to `importMap` object
- **New Error Types**: Add detection in `handleIframeError()`
- **New Fix Strategies**: Extend `handleAutoRetry()` logic

---

## Conclusion

The TSX Artifacts system provides a robust, user-friendly way to preview and interact with AI-generated React components. The combination of automatic error detection, intelligent retry mechanisms, and manual fix capabilities creates a self-healing system that improves over time.

Key architectural strengths:

1. **Modularity**: Clear separation of concerns
2. **Resilience**: Multiple error detection layers
3. **User Control**: Balance between automation and manual control
4. **Performance**: Lazy loading and caching optimizations
5. **Security**: Sandboxed execution environment

This design enables users to iterate quickly on AI-generated code while maintaining safety and performance.

